/*!
 * \file fastuidraw_painter_util.geom.glsl.resource_string
 * \brief file fastuidraw_painter_util.geom.glsl.resource_string
 *
 * Copyright 2018 by Intel.
 *
 * Contact: kevin.rogovin@intel.com
 *
 * This Source Code Form is subject to the
 * terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with
 * this file, You can obtain one at
 * http://mozilla.org/MPL/2.0/.
 *
 * \author Kevin Rogovin <kevin.rogovin@intel.com>
 *
 */
layout(triangles) in;

#ifdef FASTUIDRAW_PAINTER_GEOMETRY_SHADER_CLIPPING

layout(triangle_strip, max_vertices = 7) out;

struct fastuidraw_clipper_data_vertex
{
  vec3 barycentric;
  bool skip_vertex;
};

struct fastuidraw_clipper_data3
{
  vec3 v0, v1, v2;
};

struct fastuidraw_clipper_data4
{
  fastuidraw_clipper_data_vertex v0, v1, v2;
  vec3 last_vertex, added_vertex;
  int count, added_vertex_at;
};

struct fastuidraw_clipper_data5
{
  fastuidraw_clipper_data_vertex v0, v1, v2, v3;
  vec3 last_vertex, added_vertex;
  int count, added_vertex_at;
};

struct fastuidraw_clipper_data6
{
  fastuidraw_clipper_data_vertex v0, v1, v2, v3, v4;
  vec3 last_vertex, added_vertex;
  int count, added_vertex_at;
};

struct fastuidraw_clipper_data7
{
  fastuidraw_clipper_data_vertex v0, v1, v2, v3, v4, v5;
  vec3 last_vertex, added_vertex;
  int count, added_vertex_at;
};

void
fastuidraw_clipper_data_init(inout fastuidraw_clipper_data4 dst)
{
  dst.count = 0;
  dst.added_vertex_at = 10;
  dst.v0.skip_vertex = true;
  dst.v1.skip_vertex = true;
  dst.v2.skip_vertex = true;
}

void
fastuidraw_clipper_data_init(inout fastuidraw_clipper_data5 dst)
{
  dst.count = 0;
  dst.added_vertex_at = 10;
  dst.v0.skip_vertex = true;
  dst.v1.skip_vertex = true;
  dst.v2.skip_vertex = true;
  dst.v3.skip_vertex = true;
}

void
fastuidraw_clipper_data_init(inout fastuidraw_clipper_data6 dst)
{
  dst.count = 0;
  dst.added_vertex_at = 10;
  dst.v0.skip_vertex = true;
  dst.v1.skip_vertex = true;
  dst.v2.skip_vertex = true;
  dst.v3.skip_vertex = true;
  dst.v4.skip_vertex = true;
}

void
fastuidraw_clipper_data_init(inout fastuidraw_clipper_data7 dst)
{
  dst.count = 0;
  dst.added_vertex_at = 10;
  dst.v0.skip_vertex = true;
  dst.v1.skip_vertex = true;
  dst.v2.skip_vertex = true;
  dst.v3.skip_vertex = true;
  dst.v4.skip_vertex = true;
  dst.v5.skip_vertex = true;
}

#define fastuidraw_clipper_data_read_simple(I)                          \
  bool                                                                  \
  fastuidraw_clipper_data_read##I(in fastuidraw_clipper_data3 src,      \
                                  out vec3 dst)                         \
  {                                                                     \
    dst = src.v##I;                                                     \
    return false;                                                       \
  }

fastuidraw_clipper_data_read_simple(0)
fastuidraw_clipper_data_read_simple(1)
fastuidraw_clipper_data_read_simple(2)

#define prev1(X) X.v0
#define prev2(X) X.v1
#define prev3(X) X.v2
#define prev4(X) X.v3
#define prev5(X) X.v4

#define fastuidraw_clipper_data_read_(I, TYPE)                          \
  bool                                                                  \
  fastuidraw_clipper_data_read##I(in TYPE src, out vec3 dst)            \
  {                                                                     \
    if (I < src.added_vertex_at)                                        \
      {                                                                 \
        dst = src.v##I.barycentric;                                     \
        return src.v##I.skip_vertex;                                    \
      }                                                                 \
    else if (I > src.added_vertex_at)                                   \
      {                                                                 \
        dst = prev##I(src).barycentric;                                 \
        return prev##I(src).skip_vertex;                                \
      }                                                                 \
    else                                                                \
      {                                                                 \
        dst = src.added_vertex;                                         \
        return false;                                                   \
      }                                                                 \
  }

#define fastuidraw_clipper_data_read_first(TYPE)             \
  bool                                                       \
  fastuidraw_clipper_data_read0(in TYPE src, out vec3 dst)   \
  {                                                          \
    if (src.added_vertex_at == 0)                            \
      {                                                      \
        dst = src.added_vertex;                              \
        return false;                                        \
      }                                                      \
    else                                                     \
      {                                                      \
        dst = src.v0.barycentric;                            \
        return src.v0.skip_vertex;                           \
      }                                                      \
  }

#define fastuidraw_clipper_data_read_last(I, TYPE)           \
  bool                                                       \
  fastuidraw_clipper_data_read##I(in TYPE src, out vec3 dst) \
  {                                                          \
     dst = src.last_vertex;                                  \
     return src.count <= I;                                  \
  }


fastuidraw_clipper_data_read_first(fastuidraw_clipper_data4)
fastuidraw_clipper_data_read_(1, fastuidraw_clipper_data4)
fastuidraw_clipper_data_read_(2, fastuidraw_clipper_data4)
fastuidraw_clipper_data_read_last(3, fastuidraw_clipper_data4)

fastuidraw_clipper_data_read_first(fastuidraw_clipper_data5)
fastuidraw_clipper_data_read_(1, fastuidraw_clipper_data5)
fastuidraw_clipper_data_read_(2, fastuidraw_clipper_data5)
fastuidraw_clipper_data_read_(3, fastuidraw_clipper_data5)
fastuidraw_clipper_data_read_last(4, fastuidraw_clipper_data5)

fastuidraw_clipper_data_read_first(fastuidraw_clipper_data6)
fastuidraw_clipper_data_read_(1, fastuidraw_clipper_data6)
fastuidraw_clipper_data_read_(2, fastuidraw_clipper_data6)
fastuidraw_clipper_data_read_(3, fastuidraw_clipper_data6)
fastuidraw_clipper_data_read_(4, fastuidraw_clipper_data6)
fastuidraw_clipper_data_read_last(5, fastuidraw_clipper_data6)

fastuidraw_clipper_data_read_first(fastuidraw_clipper_data7)
fastuidraw_clipper_data_read_(1, fastuidraw_clipper_data7)
fastuidraw_clipper_data_read_(2, fastuidraw_clipper_data7)
fastuidraw_clipper_data_read_(3, fastuidraw_clipper_data7)
fastuidraw_clipper_data_read_(4, fastuidraw_clipper_data7)
fastuidraw_clipper_data_read_(5, fastuidraw_clipper_data7)
fastuidraw_clipper_data_read_last(6, fastuidraw_clipper_data7)


vec3
fastuidraw_compute_intersection(in vec3 p0, in float c0,
                                in vec3 p1, in float c1)
{
  float t;

  t = c0 / (c0 - c1);
  return mix(p0, p1, t);
}

/* 
 * Clipping against 1-plane in C++ is:
 *
 * dst.clear()
 * prev_vertex = src.back();
 * prev_d = dot(clip_values, src.back().barycentric);
 * for (int i = 0; i < src.size(); ++i)
 *   {
 *     current = src[i];
 *     current_d = dot(clip_values, current.barycentric);
 *     if (bool(current_d >= 0.0) != bool(prev_d >= 0.0))
 *       {
 *         dst.push_back(compute_split(prev_vertex, prev_d, current_vertex, current_d);
 *       }
 *
 *     if (current_d >= 0.0)
 *       {
 *         dst.push_back(current);
 *       }
 *  }
 *
 * To make this work on a GPU we:
 *  1. unroll the above loop, we realize the I'th iteration of the
 *     the loop body by invoking the macro fastuidraw_clip_polygon(I, src, dst)
 *  2. We replace the src[i] read with fastuidraw_clipper_data_read##I
 *  3. The I'th iteration ALWAYS writes to dst.v##I.
 *  4. We allow the "logical" insertion of up to one element in dst
 *     via the fields added_vertex and added_vertex_after; this is
 *     sufficient because clipping a convex polygone of n point
 *     against a plane yields a convex polygon with at most n + 1 points
 *  5. The only time an iteration will write two elements is when
 *     the current vertex is to be emitted and the previous vertex
 *     is to not be emitted. This happens at most one time.
 *     When it happens, we write this split vertex to the added vertex
 */

#define fastuidraw_clip_polygon_impl(I)                                 \
  if (!fastuidraw_clipper_data_read##I(src, current_vert))              \
    {                                                                   \
      current_d = dot(clip_values, current_vert);                       \
      if (current_d >= 0.0)                                             \
        {                                                               \
          if (prev_d < 0.0)                                             \
            {                                                           \
              vec3 p;                                                   \
              p = fastuidraw_compute_intersection(prev_vert, prev_d,    \
                                                  current_vert, current_d); \
              dst.added_vertex_at = I;                                  \
              dst.added_vertex = p;                                     \
              ++dst.count;                                              \
            }                                                           \
          dst.v##I.skip_vertex = false;                                 \
          dst.v##I.barycentric = current_vert;                          \
          ++dst.count;                                                  \
          dst.last_vertex = current_vert;                               \
        }                                                               \
      else if (prev_d >= 0.0)                                           \
        {                                                               \
          vec3 p;                                                       \
          p = fastuidraw_compute_intersection(prev_vert, prev_d,        \
                                              current_vert, current_d); \
          dst.v##I.skip_vertex = false;                                 \
          dst.v##I.barycentric = p;                                     \
          ++dst.count;                                                  \
          dst.last_vertex = p;                                          \
        }                                                               \
                                                                        \
      prev_vert = current_vert;                                         \
      prev_d = current_d;                                               \
    }


void
fastuidraw_clip_polygon3(in fastuidraw_clipper_data3 src,
                         in vec3 clip_values,
                         out fastuidraw_clipper_data4 dst)
{
  vec3 current_vert, prev_vert;
  float current_d, prev_d;

  prev_vert = src.v2;
  prev_d = dot(clip_values, prev_vert);

  fastuidraw_clipper_data_init(dst);
  fastuidraw_clip_polygon_impl(0)
  fastuidraw_clip_polygon_impl(1)
  fastuidraw_clip_polygon_impl(2)
}

void
fastuidraw_clip_polygon4(in fastuidraw_clipper_data4 src,
                         in vec3 clip_values,
                         out fastuidraw_clipper_data5 dst)
{
  vec3 current_vert, prev_vert;
  float current_d, prev_d;

  prev_vert = src.last_vertex;
  prev_d = dot(clip_values, prev_vert);

  fastuidraw_clipper_data_init(dst);
  if (src.count >= 3)
    {
      fastuidraw_clip_polygon_impl(0)
      fastuidraw_clip_polygon_impl(1)
      fastuidraw_clip_polygon_impl(2)
      fastuidraw_clip_polygon_impl(3)
    }
}

void
fastuidraw_clip_polygon5(in fastuidraw_clipper_data5 src,
                         in vec3 clip_values,
                         out fastuidraw_clipper_data6 dst)
{
  vec3 current_vert, prev_vert;
  float current_d, prev_d;

  prev_vert = src.last_vertex;
  prev_d = dot(clip_values, prev_vert);

  fastuidraw_clipper_data_init(dst);
  if (src.count >= 3)
    {
      fastuidraw_clip_polygon_impl(0)
      fastuidraw_clip_polygon_impl(1)
      fastuidraw_clip_polygon_impl(2)
      fastuidraw_clip_polygon_impl(3)
      fastuidraw_clip_polygon_impl(4)
    }
}

void
fastuidraw_clip_polygon6(in fastuidraw_clipper_data6 src,
                         in vec3 clip_values,
                         out fastuidraw_clipper_data7 dst)
{
  vec3 current_vert, prev_vert;
  float current_d, prev_d;

  prev_vert = src.last_vertex;
  prev_d = dot(clip_values, prev_vert);

  fastuidraw_clipper_data_init(dst);
  if (src.count >= 3)
    {
      fastuidraw_clip_polygon_impl(0)
      fastuidraw_clip_polygon_impl(1)
      fastuidraw_clip_polygon_impl(2)
      fastuidraw_clip_polygon_impl(3)
      fastuidraw_clip_polygon_impl(4)
      fastuidraw_clip_polygon_impl(5)
    }
}

#define fastuidraw_clipper_data_emit_worker(I) \
  if (!fastuidraw_clipper_data_read##I(src, p)) \
    {                                           \
      prev_vertex = p;                          \
    }                                           \
  fastuidraw_emit_vertex(prev_vertex);

void
fastuidraw_clipper_data_emit(in fastuidraw_clipper_data7 src)
{
  if (src.count >= 3)
    {
      vec3 prev_vertex, p;

      prev_vertex = src.last_vertex;
      fastuidraw_clipper_data_emit_worker(0)
      fastuidraw_clipper_data_emit_worker(6)
      fastuidraw_clipper_data_emit_worker(1)
      fastuidraw_clipper_data_emit_worker(5)
      fastuidraw_clipper_data_emit_worker(2)
      fastuidraw_clipper_data_emit_worker(4)
      fastuidraw_clipper_data_emit_worker(3)
      EndPrimitive();
    }
}

void
fastuidraw_clipper_data_emit(in fastuidraw_clipper_data6 src)
{
  if (src.count >= 3)
    {
      vec3 prev_vertex, p;

      prev_vertex = src.last_vertex;
      fastuidraw_clipper_data_emit_worker(0)
      fastuidraw_clipper_data_emit_worker(5)
      fastuidraw_clipper_data_emit_worker(1)
      fastuidraw_clipper_data_emit_worker(4)
      fastuidraw_clipper_data_emit_worker(2)
      fastuidraw_clipper_data_emit_worker(3)
      EndPrimitive();
    }
}

void
fastuidraw_clipper_data_emit(in fastuidraw_clipper_data5 src)
{
  if (src.count >= 3)
    {
      vec3 prev_vertex, p;

      prev_vertex = src.last_vertex;
      fastuidraw_clipper_data_emit_worker(0)
      fastuidraw_clipper_data_emit_worker(4)
      fastuidraw_clipper_data_emit_worker(1)
      fastuidraw_clipper_data_emit_worker(3)
      fastuidraw_clipper_data_emit_worker(2)
      EndPrimitive();
    }
}

void
fastuidraw_clipper_data_emit(in fastuidraw_clipper_data4 src)
{
   if (src.count >= 3)
    {
      vec3 prev_vertex, p;

      prev_vertex = src.last_vertex;
      fastuidraw_clipper_data_emit_worker(0)
      fastuidraw_clipper_data_emit_worker(3)
      fastuidraw_clipper_data_emit_worker(1)
      fastuidraw_clipper_data_emit_worker(2)
      EndPrimitive();
    }
}

void
main(void)
{
  fastuidraw_clipper_data3 A0;
  fastuidraw_clipper_data4 A1;
  fastuidraw_clipper_data5 A2;
  fastuidraw_clipper_data6 A3;
  fastuidraw_clipper_data7 A4;
  vec3 C;

  A0.v0 = vec3(1.0, 0.0, 0.0);
  A0.v1 = vec3(0.0, 1.0, 0.0);
  A0.v2 = vec3(0.0, 0.0, 1.0);

  C.x = fastuidraw_in[0].fastuidraw_clip_planes.x;
  C.y = fastuidraw_in[1].fastuidraw_clip_planes.x;
  C.z = fastuidraw_in[2].fastuidraw_clip_planes.x;
  fastuidraw_clip_polygon3(A0, C, A1);

  C.x = fastuidraw_in[0].fastuidraw_clip_planes.y;
  C.y = fastuidraw_in[1].fastuidraw_clip_planes.y;
  C.z = fastuidraw_in[2].fastuidraw_clip_planes.y;
  fastuidraw_clip_polygon4(A1, C, A2);

  C.x = fastuidraw_in[0].fastuidraw_clip_planes.z;
  C.y = fastuidraw_in[1].fastuidraw_clip_planes.z;
  C.z = fastuidraw_in[2].fastuidraw_clip_planes.z;
  fastuidraw_clip_polygon5(A2, C, A3);

  C.x = fastuidraw_in[0].fastuidraw_clip_planes.w;
  C.y = fastuidraw_in[1].fastuidraw_clip_planes.w;
  C.z = fastuidraw_in[2].fastuidraw_clip_planes.w;
  fastuidraw_clip_polygon6(A3, C, A4);

  fastuidraw_clipper_data_emit(A1);
}

#else

layout(triangle_strip, max_vertices = 3) out;
void
main(void)
{
  fastuidraw_emit_vertex(vec3(1.0, 0.0, 0.0));
  fastuidraw_emit_vertex(vec3(0.0, 1.0, 0.0));
  fastuidraw_emit_vertex(vec3(0.0, 0.0, 1.0));
}

#endif
